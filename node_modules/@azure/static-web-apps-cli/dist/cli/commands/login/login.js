"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.login = exports.loginCommand = void 0;
const chalk_1 = __importDefault(require("chalk"));
const dotenv_1 = __importDefault(require("dotenv"));
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const core_1 = require("../../../core");
const account_1 = require("../../../core/account");
const constants_1 = require("../../../core/constants");
const git_1 = require("../../../core/git");
const prompts_1 = require("../../../core/prompts");
const azure_environment_1 = require("../../../core/swa-cli-persistence-plugin/impl/azure-environment");
const { readFile, writeFile } = fs_1.promises;
const defaultScope = `${azure_environment_1.Environment.AzureCloud.resourceManagerEndpointUrl}/.default`;
async function loginCommand(options) {
    try {
        const { credentialChain, subscriptionId } = await login(options);
        if (credentialChain && subscriptionId) {
            core_1.logger.log(chalk_1.default.green(`✔ Successfully setup project!`));
        }
        else {
            core_1.logger.log(chalk_1.default.red(`✘ Failed to setup project!`));
            (0, core_1.logGiHubIssueMessageAndExit)();
        }
    }
    catch (error) {
        core_1.logger.error(`Failed to setup project: ${error.message}`);
        (0, core_1.logGiHubIssueMessageAndExit)();
    }
}
exports.loginCommand = loginCommand;
async function login(options) {
    let credentialChain = undefined;
    core_1.logger.log(`Checking Azure session...`);
    let tenantId = options.tenantId;
    let clientId = options.clientId;
    let clientSecret = options.clientSecret;
    credentialChain = await (0, account_1.authenticateWithAzureIdentity)({ tenantId, clientId, clientSecret }, options.useKeychain, options.clearCredentials);
    if (await credentialChain.getToken(defaultScope)) {
        core_1.logger.log(chalk_1.default.green(`✔ Successfully logged into Azure!`));
    }
    return await setupProjectCredentials(options, credentialChain);
}
exports.login = login;
async function setupProjectCredentials(options, credentialChain) {
    let { subscriptionId, tenantId, clientId, clientSecret } = options;
    // If the user has not specified a tenantId, we will prompt them to choose one
    if (!tenantId) {
        const tenants = await (0, account_1.listTenants)(credentialChain);
        if (tenants.length === 0) {
            throw new Error(`No Azure tenants found in your account.\n  Please read https://docs.microsoft.com/azure/cost-management-billing/manage/troubleshoot-sign-in-issue`);
        }
        else if (tenants.length === 1) {
            core_1.logger.silly(`Found 1 tenant: ${tenants[0].tenantId}`);
            tenantId = tenants[0].tenantId;
        }
        else {
            const tenant = await (0, prompts_1.chooseTenant)(tenants, options.tenantId);
            tenantId = tenant === null || tenant === void 0 ? void 0 : tenant.tenantId;
            // login again with the new tenant
            // TODO: can we silently authenticate the user with the new tenant?
            credentialChain = await (0, account_1.authenticateWithAzureIdentity)({ tenantId, clientId, clientSecret }, options.useKeychain, true);
            if (await credentialChain.getToken(defaultScope)) {
                core_1.logger.log(chalk_1.default.green(`✔ Successfully logged into Azure tenant: ${tenantId}`));
            }
        }
    }
    core_1.logger.silly(`Selected tenant: ${tenantId}`);
    // If the user has not specified a subscriptionId, we will prompt them to choose one
    if (!subscriptionId) {
        const subscriptions = await (0, account_1.listSubscriptions)(credentialChain);
        if (subscriptions.length === 0) {
            throw new Error(`No valid subscription found for tenant ${tenantId}.\n  Please read https://docs.microsoft.com/azure/cost-management-billing/manage/no-subscriptions-found`);
        }
        else if (subscriptions.length === 1) {
            core_1.logger.silly(`Found 1 subscription: ${subscriptions[0].subscriptionId}`);
            subscriptionId = subscriptions[0].subscriptionId;
        }
        else {
            const subscription = await (0, prompts_1.chooseSubscription)(subscriptions, subscriptionId);
            subscriptionId = subscription === null || subscription === void 0 ? void 0 : subscription.subscriptionId;
        }
    }
    core_1.logger.silly(`Selected subscription: ${subscriptionId}`);
    core_1.logger.silly(`Project credentials:`);
    core_1.logger.silly({ subscriptionId, tenantId, clientId, clientSecret });
    await storeProjectCredentialsInEnvFile(subscriptionId, tenantId, clientId, clientSecret);
    return {
        credentialChain,
        subscriptionId: subscriptionId,
    };
}
async function storeProjectCredentialsInEnvFile(subscriptionId, tenantId, clientId, clientSecret) {
    const envFile = path_1.default.join(process.cwd(), constants_1.ENV_FILENAME);
    const envFileExists = (0, fs_1.existsSync)(envFile);
    const envFileContent = envFileExists ? await readFile(envFile, "utf8") : "";
    const buf = Buffer.from(envFileContent);
    // in case the .env file format changes in the future, we can use the following to parse the file
    const config = dotenv_1.default.parse(buf);
    const oldEnvFileLines = Object.keys(config).map((key) => `${key}=${config[key]}`);
    const newEnvFileLines = [];
    let entry = `AZURE_SUBSCRIPTION_ID=${subscriptionId}`;
    if (subscriptionId && !envFileContent.includes(entry)) {
        newEnvFileLines.push(entry);
    }
    entry = `AZURE_TENANT_ID=${tenantId}`;
    if (tenantId && !envFileContent.includes(entry)) {
        newEnvFileLines.push(entry);
    }
    entry = `AZURE_CLIENT_ID=${clientId}`;
    if (clientId && !envFileContent.includes(entry)) {
        newEnvFileLines.push(entry);
    }
    entry = `AZURE_CLIENT_SECRET=${clientSecret}`;
    if (clientSecret && !envFileContent.includes(entry)) {
        newEnvFileLines.push(entry);
    }
    // write file if we have at least one new env line
    if (newEnvFileLines.length > 0) {
        const envFileContentWithProjectDetails = [...oldEnvFileLines, ...newEnvFileLines].join("\n");
        await writeFile(envFile, envFileContentWithProjectDetails);
        core_1.logger.log(chalk_1.default.green(`✔ Saved project credentials in ${constants_1.ENV_FILENAME} file.`));
        await (0, git_1.updateGitIgnore)(constants_1.ENV_FILENAME);
    }
}
//# sourceMappingURL=login.js.map