"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.start = void 0;
const concurrently_1 = __importDefault(require("concurrently"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const core_1 = require("../../../core");
const env_1 = require("../../../core/env");
const ssl_1 = require("../../../core/ssl");
const packageInfo = require("../../../../package.json");
const mshaPath = require.resolve("../../../msha/server");
async function start(options) {
    // WARNING:
    // environment variables are populated using values provided by the user to the CLI.
    // Code below doesn't have access to these environment variables which are defined later below.
    // Make sure this code (or code from utils) does't depend on environment variables!
    var _a, _b, _c, _d, _e;
    let { appLocation, apiLocation, outputLocation, appDevserverUrl, apiDevserverUrl, apiPort, devserverTimeout, ssl, sslCert, sslKey, host, port, run, open, funcArgs, swaConfigLocation, verbose, } = options;
    let useApiDevServer = undefined;
    let startupCommand = undefined;
    let resolvedPortNumber = await (0, core_1.isAcceptingTcpConnections)({ host, port });
    if (resolvedPortNumber === 0) {
        core_1.logger.warn(`Port ${port} is already taken!`);
        resolvedPortNumber = await (0, core_1.askNewPort)();
    }
    else {
        core_1.logger.silly(`Port ${port} is available. Use it.`);
    }
    // still no luck or user refused to use a random port
    if (resolvedPortNumber === 0) {
        core_1.logger.error(`Port ${port} is already in use. Use '--port' to specify a different port.`, true);
    }
    // set the new port number in case we picked a new one (see net.isAcceptingTcpConnections())
    core_1.logger.silly(`Resolved port number: ${resolvedPortNumber}`);
    port = resolvedPortNumber;
    // resolve the absolute path to the appLocation
    appLocation = path_1.default.resolve(appLocation);
    if (appDevserverUrl) {
        core_1.logger.silly(`appDevserverUrl provided, we will try connect to dev server at ${outputLocation}`);
        // TODO: properly refactor this after GA to send appDevserverUrl to the server
        outputLocation = appDevserverUrl;
    }
    else {
        core_1.logger.silly(`Resolving outputLocation=${outputLocation} full path...`);
        let resolvedOutputLocation = path_1.default.resolve(appLocation, outputLocation);
        // if folder exists, start the emulator from a specific build folder (outputLocation), relative to appLocation
        if (fs_1.default.existsSync(resolvedOutputLocation)) {
            outputLocation = resolvedOutputLocation;
        }
        // check for build folder (outputLocation) using the absolute location
        else if (!fs_1.default.existsSync(outputLocation)) {
            core_1.logger.error(`The folder "${resolvedOutputLocation}" is not found. Exit.`, true);
            return;
        }
        core_1.logger.silly(`Resolved outputLocation:`);
        core_1.logger.silly(`  ${outputLocation}`);
    }
    if (apiDevserverUrl) {
        // TODO: properly refactor this after GA to send apiDevserverUrl to the server
        useApiDevServer = apiDevserverUrl;
        apiLocation = apiDevserverUrl;
    }
    else if (apiLocation) {
        // resolves to the absolute path of the apiLocation
        let resolvedApiLocation = path_1.default.resolve(apiLocation);
        // make sure api folder exists
        if (fs_1.default.existsSync(resolvedApiLocation)) {
            apiLocation = resolvedApiLocation;
        }
        else {
            core_1.logger.info(`Skipping API because folder "${resolvedApiLocation}" is missing`, "swa");
        }
    }
    let userWorkflowConfig = {
        appLocation,
        outputLocation,
        apiLocation,
    };
    // mix CLI args with the project's build workflow configuration (if any)
    // use any specific workflow config that the user might provide undef ".github/workflows/"
    // Note: CLI args will take precedence over workflow config
    try {
        // TODO: not sure if we should still do this here, as config/user options should override
        // over any options in the workflow config, but it seems to do the opposite here.
        userWorkflowConfig = (0, core_1.readWorkflowFile)({
            userWorkflowConfig,
        });
        core_1.logger.silly(`User workflow config:`);
        core_1.logger.silly(userWorkflowConfig);
    }
    catch (err) {
        core_1.logger.warn(``);
        core_1.logger.warn(`Error reading workflow configuration:`);
        core_1.logger.warn(err.message);
        core_1.logger.warn(`See https://docs.microsoft.com/azure/static-web-apps/build-configuration?tabs=github-actions#build-configuration for more information.`);
    }
    const isApiLocationExistsOnDisk = fs_1.default.existsSync(userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.apiLocation);
    // handle the API location config
    let serveApiCommand = "echo 'No API found. Skipping'";
    if (useApiDevServer) {
        serveApiCommand = `echo 'using API dev server at ${useApiDevServer}'`;
        // get the API port from the dev server
        apiPort = (_a = (0, core_1.parseUrl)(useApiDevServer)) === null || _a === void 0 ? void 0 : _a.port;
    }
    else {
        if (apiLocation && (userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.apiLocation)) {
            // check if the func binary is globally available and if not, download it
            const funcBinary = await (0, core_1.getCoreToolsBinary)();
            const nodeMajorVersion = (0, core_1.getNodeMajorVersion)();
            const targetVersion = (0, core_1.detectTargetCoreToolsVersion)(nodeMajorVersion);
            if (!funcBinary) {
                // prettier-ignore
                core_1.logger.error(`\nCould not find or install Azure Functions Core Tools.\n` +
                    `Install Azure Functions Core Tools with:\n\n` +
                    `  npm i -g azure-functions-core-tools@${targetVersion} --unsafe-perm true\n\n` +
                    `See https://aka.ms/functions-core-tools for more information.`, true);
            }
            else {
                if ((0, core_1.isCoreToolsVersionCompatible)(targetVersion, nodeMajorVersion) === false) {
                    core_1.logger.error(`Found Azure Functions Core Tools v${targetVersion} which is incompatible with your current Node.js v${process.versions.node}.`);
                    core_1.logger.error("See https://aka.ms/functions-node-versions for more information.");
                    process.exit(1);
                }
                // serve the api if and only if the user provides a folder via the --api-location flag
                if (isApiLocationExistsOnDisk) {
                    serveApiCommand = `cd "${userWorkflowConfig.apiLocation}" && "${funcBinary}" start --cors "*" --port ${apiPort} ${funcArgs !== null && funcArgs !== void 0 ? funcArgs : ""}`;
                }
            }
        }
    }
    if (ssl) {
        if (sslCert === undefined && sslKey === undefined) {
            core_1.logger.warn(`WARNING: Using built-in UNSIGNED certificate. DO NOT USE IN PRODUCTION!`);
            const pemFilepath = await (0, ssl_1.getCertificate)({
                selfSigned: true,
                days: 365,
                commonName: host,
                organization: `Azure Static Web Apps CLI ${packageInfo.version}`,
                organizationUnit: "Azure Engineering",
                emailAddress: `secure@microsoft.com`,
            });
            sslCert = pemFilepath;
            sslKey = pemFilepath;
        }
        else {
            // user provided cert and key, so we'll use them
            sslCert = sslCert && path_1.default.resolve(sslCert);
            sslKey = sslKey && path_1.default.resolve(sslKey);
        }
    }
    if (run) {
        startupCommand = (0, core_1.createStartupScriptCommand)(run, options);
    }
    // resolve the following config to their absolute paths
    // note: the server will perform a search starting from this path
    swaConfigLocation = path_1.default.resolve(swaConfigLocation || (userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.appLocation) || process.cwd());
    // WARNING: code from above doesn't have access to env vars which are only defined below
    // set env vars for current command
    const envVarsObj = {
        SWA_RUNTIME_CONFIG_LOCATION: swaConfigLocation,
        SWA_RUNTIME_WORKFLOW_LOCATION: (_b = userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.files) === null || _b === void 0 ? void 0 : _b[0],
        SWA_CLI_DEBUG: verbose,
        SWA_CLI_API_PORT: `${apiPort}`,
        SWA_CLI_APP_LOCATION: userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.appLocation,
        SWA_CLI_OUTPUT_LOCATION: userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.outputLocation,
        SWA_CLI_API_LOCATION: userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.apiLocation,
        SWA_CLI_HOST: `${host}`,
        SWA_CLI_PORT: `${port}`,
        SWA_CLI_APP_SSL: ssl ? "true" : "false",
        SWA_CLI_APP_SSL_CERT: sslCert,
        SWA_CLI_APP_SSL_KEY: sslKey,
        SWA_CLI_STARTUP_COMMAND: startupCommand,
        SWA_CLI_VERSION: packageInfo.version,
        SWA_CLI_SERVER_TIMEOUT: `${devserverTimeout}`,
        SWA_CLI_OPEN_BROWSER: open ? "true" : "false",
    };
    // merge SWA CLI env variables with process.env
    process.env = {
        ...(0, env_1.swaCLIEnv)(envVarsObj),
        // Prevent react-scripts from opening browser
        BROWSER: "none",
    };
    // INFO: from here, code may access SWA CLI env vars.
    const env = (0, env_1.swaCLIEnv)();
    const concurrentlyCommands = [
        // start the reverse proxy
        { command: `node "${mshaPath}"`, name: "swa", env, prefixColor: "gray.dim" },
    ];
    if (isApiLocationExistsOnDisk) {
        concurrentlyCommands.push(
        // serve the api, if it's available
        { command: serveApiCommand, name: "api", env, prefixColor: "gray.dim" });
    }
    // run an external script, if it's available
    if (startupCommand) {
        let startupPath = userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.appLocation;
        concurrentlyCommands.push({ command: `cd "${startupPath}" && ${startupCommand}`, name: "run", env, prefixColor: "gray.dim" });
    }
    core_1.logger.silly(`Starting the SWA emulator with the following configuration:`);
    core_1.logger.silly({
        ssl: [ssl, sslCert, sslKey],
        env: envVarsObj,
        commands: {
            swa: (_c = concurrentlyCommands.find((c) => c.name === "swa")) === null || _c === void 0 ? void 0 : _c.command,
            api: (_d = concurrentlyCommands.find((c) => c.name === "api")) === null || _d === void 0 ? void 0 : _d.command,
            run: (_e = concurrentlyCommands.find((c) => c.name === "run")) === null || _e === void 0 ? void 0 : _e.command,
        },
    });
    const { result } = (0, concurrently_1.default)(concurrentlyCommands, { restartTries: 0, killOthers: ["failure", "success"] });
    await result
        .then((errorEvent) => {
        const killedCommand = errorEvent.filter((event) => event.killed).pop();
        const exitCode = killedCommand === null || killedCommand === void 0 ? void 0 : killedCommand.exitCode;
        core_1.logger.silly(`SWA emulator exited with code ${exitCode}`);
        process.exit();
    }, (errorEvent) => {
        const killedCommand = errorEvent.filter((event) => event.killed).pop();
        const commandName = killedCommand === null || killedCommand === void 0 ? void 0 : killedCommand.command.name;
        const exitCode = killedCommand === null || killedCommand === void 0 ? void 0 : killedCommand.exitCode;
        let commandMessage = ``;
        switch (commandName) {
            case "swa":
                commandMessage = `SWA emulator exited with code ${exitCode}`;
                break;
            case "api":
                commandMessage = `API server exited with code ${exitCode}`;
                break;
            case "run":
                commandMessage = `the --run command exited with code ${exitCode}`;
                break;
        }
        core_1.logger.error(`SWA emulator stoped because ${commandMessage}.`, true);
    })
        .catch((err) => {
        core_1.logger.error(err.message, true);
    });
}
exports.start = start;
//# sourceMappingURL=start.js.map