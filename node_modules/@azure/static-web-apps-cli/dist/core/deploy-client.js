"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cleanUp = exports.fetchClientVersionDefinition = exports.getPlatform = exports.getLocalClientMetadata = exports.getDeployClientPath = exports.DEPLOY_FOLDER = exports.DEPLOY_BINARY_NAME = void 0;
const chalk_1 = __importDefault(require("chalk"));
const crypto_1 = __importDefault(require("crypto"));
const fs_1 = __importDefault(require("fs"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const ora_1 = __importDefault(require("ora"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const stream_1 = require("stream");
const constants_1 = require("./constants");
const env_1 = require("./env");
const utils_1 = require("./utils");
exports.DEPLOY_BINARY_NAME = "StaticSitesClient";
exports.DEPLOY_FOLDER = path_1.default.join(os_1.default.homedir(), ".swa", "deploy");
async function getDeployClientPath() {
    const platform = getPlatform();
    if (!platform) {
        throw new Error(`Unsupported platform: ${os_1.default.platform()}`);
    }
    const localClientMetadata = getLocalClientMetadata();
    const binaryVersion = (0, env_1.swaCLIEnv)().SWA_CLI_DEPLOY_BINARY_VERSION || "stable";
    const remoteClientMetadata = await fetchClientVersionDefinition(binaryVersion);
    if (remoteClientMetadata === undefined) {
        throw new Error(`Could not load ${exports.DEPLOY_BINARY_NAME} metadata from remote. Please check your internet connection.`);
    }
    // if the latest version is the same as the local version, we can skip the download
    if (localClientMetadata) {
        if (!localClientMetadata.metadata || !localClientMetadata.binary || !localClientMetadata.checksum) {
            utils_1.logger.warn(`Local client metadata is invalid!`);
        }
        else {
            const localChecksum = localClientMetadata.checksum;
            const releaseChecksum = remoteClientMetadata.files[platform].sha.toLowerCase();
            const remoteBuildId = remoteClientMetadata.buildId;
            const localBuildId = localClientMetadata.metadata.buildId;
            if (remoteBuildId === localBuildId) {
                if (localChecksum === releaseChecksum) {
                    utils_1.logger.silly(`Local client binary is up to date. Skipping download.`);
                    return {
                        binary: localClientMetadata.binary,
                        buildId: localBuildId,
                    };
                }
                else {
                    utils_1.logger.warn(`Local metatada contains invalid checksum hash!`);
                    utils_1.logger.warn(`  Expected ${releaseChecksum}`);
                    utils_1.logger.warn(`  Received ${localChecksum}`);
                }
            }
            else {
                if (localBuildId) {
                    utils_1.logger.warn(`${exports.DEPLOY_BINARY_NAME} is outdated! Expected ${remoteBuildId}, got ${localBuildId}`);
                }
            }
        }
    }
    return {
        binary: await downloadAndValidateBinary(remoteClientMetadata, platform),
        buildId: remoteClientMetadata.buildId,
    };
}
exports.getDeployClientPath = getDeployClientPath;
function getLocalClientMetadata() {
    const metadataFilename = path_1.default.join(exports.DEPLOY_FOLDER, `${exports.DEPLOY_BINARY_NAME}.json`);
    if (!fs_1.default.existsSync(metadataFilename)) {
        utils_1.logger.warn(`Could not find ${exports.DEPLOY_BINARY_NAME} local binary`);
        return null;
    }
    let metadata = null;
    try {
        metadata = JSON.parse(fs_1.default.readFileSync(metadataFilename, "utf8"));
    }
    catch (err) {
        utils_1.logger.warn(`Could not read ${exports.DEPLOY_BINARY_NAME} metadata: ${err}`);
        return null;
    }
    if (metadata) {
        if (!fs_1.default.existsSync(metadata.binary)) {
            utils_1.logger.warn(`Could not find ${exports.DEPLOY_BINARY_NAME} binary: ${metadata.binary}`);
            return null;
        }
        else if (fs_1.default.existsSync(metadata.binary)) {
            return metadata;
        }
    }
    return null;
}
exports.getLocalClientMetadata = getLocalClientMetadata;
function computeChecksumfromFile(filePath) {
    if (!filePath || !fs_1.default.existsSync(filePath)) {
        return "";
    }
    const buffer = fs_1.default.readFileSync(filePath);
    const hash = crypto_1.default.createHash("sha256");
    hash.update(buffer);
    return hash.digest("hex");
}
function getPlatform() {
    switch (os_1.default.platform()) {
        case "win32":
            return "win-x64";
        case "darwin":
            return "osx-x64";
        case "aix":
        case "freebsd":
        case "openbsd":
        case "sunos":
        case "linux":
            return "linux-x64";
        default:
            return null;
    }
}
exports.getPlatform = getPlatform;
async function fetchClientVersionDefinition(releaseVersion) {
    utils_1.logger.silly(`Fetching release metadata for version: ${releaseVersion}. Please wait...`);
    const remoteVersionDefinitions = (await (0, node_fetch_1.default)(constants_1.STATIC_SITE_CLIENT_RELEASE_METADATA_URL).then((res) => res.json()));
    if (Array.isArray(remoteVersionDefinitions) && remoteVersionDefinitions.length) {
        const releaseMetadata = remoteVersionDefinitions.find((versionDefinition) => (versionDefinition === null || versionDefinition === void 0 ? void 0 : versionDefinition.version) === releaseVersion);
        utils_1.logger.silly(releaseMetadata);
        return releaseMetadata;
    }
    return undefined;
}
exports.fetchClientVersionDefinition = fetchClientVersionDefinition;
async function downloadAndValidateBinary(release, platform) {
    var _a;
    const downloadUrl = release.files[platform].url;
    const downloadFilename = path_1.default.basename(downloadUrl);
    const url = release.files[platform].url;
    const buildId = release.buildId;
    const spinner = (0, ora_1.default)({ prefixText: chalk_1.default.dim.gray(`[swa]`) });
    spinner.start(`Downloading ${url}@${buildId}`);
    const response = await (0, node_fetch_1.default)(url);
    if (response.status !== 200) {
        spinner.fail();
        throw new Error(`Failed to download ${exports.DEPLOY_BINARY_NAME} binary. File not found (${response.status})`);
    }
    const bodyStream = (_a = response === null || response === void 0 ? void 0 : response.body) === null || _a === void 0 ? void 0 : _a.pipe(new stream_1.PassThrough());
    createDeployDirectoryIfNotExists(buildId);
    return await new Promise((resolve, reject) => {
        const isPosix = platform === "linux-x64" || platform === "osx-x64";
        let outputFile = path_1.default.join(exports.DEPLOY_FOLDER, buildId, downloadFilename);
        const writableStream = fs_1.default.createWriteStream(outputFile, { mode: isPosix ? 0o755 : undefined });
        bodyStream === null || bodyStream === void 0 ? void 0 : bodyStream.pipe(writableStream);
        writableStream.on("end", () => {
            bodyStream === null || bodyStream === void 0 ? void 0 : bodyStream.end();
        });
        writableStream.on("finish", () => {
            const computedHash = computeChecksumfromFile(outputFile).toLowerCase();
            const releaseChecksum = release.files[platform].sha.toLocaleLowerCase();
            if (computedHash !== releaseChecksum) {
                try {
                    // in case of a failure, we remove the file
                    fs_1.default.unlinkSync(outputFile);
                }
                catch { }
                spinner.fail();
                reject(new Error(`Checksum mismatch! Expected ${computedHash}, got ${releaseChecksum}.`));
            }
            else {
                spinner.succeed();
                utils_1.logger.silly(`Checksum match: ${computedHash}`);
                utils_1.logger.silly(`Saved binary to ${outputFile}`);
                saveMetadata(release, outputFile, computedHash);
                resolve(outputFile);
            }
        });
    });
}
function saveMetadata(release, binaryFilename, sha) {
    const metatdaFilename = path_1.default.join(exports.DEPLOY_FOLDER, `${exports.DEPLOY_BINARY_NAME}.json`);
    const metdata = {
        metadata: release,
        binary: binaryFilename,
        checksum: sha,
    };
    fs_1.default.writeFileSync(metatdaFilename, JSON.stringify(metdata));
    utils_1.logger.silly(`Saved metadata to ${metatdaFilename}`);
}
// TODO: get StaticSiteClient to remove zip files
// TODO: can these ZIPs be created under /tmp?
function cleanUp() {
    const clean = (file) => {
        const filepath = path_1.default.join(process.cwd(), file);
        if (fs_1.default.existsSync(filepath)) {
            try {
                fs_1.default.unlinkSync(filepath);
            }
            catch { }
        }
    };
    clean(".\\app.zip");
    clean(".\\api.zip");
}
exports.cleanUp = cleanUp;
function createDeployDirectoryIfNotExists(version) {
    const deployPath = path_1.default.join(exports.DEPLOY_FOLDER, version);
    if (!fs_1.default.existsSync(deployPath)) {
        fs_1.default.mkdirSync(deployPath, { recursive: true });
    }
}
//# sourceMappingURL=deploy-client.js.map