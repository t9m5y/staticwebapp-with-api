"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCertificate = void 0;
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const pem_1 = __importDefault(require("pem"));
const utils_1 = require("./utils");
const fs = fs_1.default.promises;
const { mkdir, writeFile } = fs;
const ONE_MONTH = 1000 * 60 * 60 * 24 * 30;
/**
 * Generate a new SSL certificate. This will create a new key and certificate and cache them in the
 * `~/.swa/certificates/ssl` directory, for one month.
 *
 * @param options PEM options (passed to the "`pem`" npm library)
 * @returns The abosulte filepath to the PEM file from cache.
 */
async function getCertificate(options) {
    const cacheDir = path_1.default.join(os_1.default.homedir(), ".swa", "certificates", "ssl");
    const cachePath = path_1.default.join(cacheDir, "swa-cli-UNSIGNED.pem");
    try {
        utils_1.logger.silly(`Checking for cached certificate at ${cachePath}`);
        const [stat, unsignedCertificate] = await Promise.all([fs.stat(cachePath), fs.readFile(cachePath, "utf8")]);
        if (Date.now() - stat.ctime.valueOf() > ONE_MONTH) {
            throw new Error("Certificate is too old, a new one will be generated.");
        }
        utils_1.logger.silly("Certificate is valid, using it.");
        return unsignedCertificate;
    }
    catch {
        utils_1.logger.silly("No cached certificate found.");
        utils_1.logger.silly("Creating new certificate...");
        const unsignedCertificate = await createCertificate(options);
        utils_1.logger.silly("Writing certificate to cache...");
        const pemContent = [unsignedCertificate.csr, unsignedCertificate.serviceKey, unsignedCertificate.certificate].join("\n");
        await mkdir(cacheDir, { recursive: true });
        await writeFile(cachePath, pemContent);
        return cachePath;
    }
}
exports.getCertificate = getCertificate;
async function createCertificate(options) {
    return new Promise((resolve, reject) => {
        pem_1.default.createCertificate(options, (err, keys) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(keys);
            }
        });
    });
}
//# sourceMappingURL=ssl.js.map