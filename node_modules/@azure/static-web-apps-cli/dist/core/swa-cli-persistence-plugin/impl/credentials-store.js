"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NativeCredentialsStore = void 0;
const os_1 = __importDefault(require("os"));
const wait_on_1 = __importDefault(require("wait-on"));
const utils_1 = require("../../utils");
class NativeCredentialsStore {
    constructor(options) {
        this.options = options;
    }
    async getPassword(service, account) {
        utils_1.logger.silly("Getting credentials from native keychain");
        const keychain = await this.requireKeychain();
        utils_1.logger.silly("Got native keychain reference");
        const credentials = await keychain.getPassword(service, account);
        utils_1.logger.silly("Got credentials from native keychain: " + (credentials ? "<hidden>" : "<empty>"));
        if (credentials) {
            utils_1.logger.silly("Credentials found in native keychain");
            try {
                let { content, hasNextChunk } = JSON.parse(credentials);
                if (!content || !hasNextChunk) {
                    return credentials;
                }
                utils_1.logger.silly("Credentials is chunked. Reading all chunks...");
                let index = 1;
                while (hasNextChunk) {
                    const nextChunk = await keychain.getPassword(service, `${account}-${index}`);
                    const result = JSON.parse(nextChunk);
                    content += result.content;
                    hasNextChunk = result.hasNextChunk;
                    index++;
                }
                utils_1.logger.silly("Got all chunks successfully");
                return content;
            }
            catch {
                utils_1.logger.silly("Credentials is not chunked");
                utils_1.logger.silly("Returning credentials as is");
                return credentials;
            }
        }
        utils_1.logger.silly("Credentials not found in native keychain");
        return credentials;
    }
    async setPassword(service, account, credentials) {
        utils_1.logger.silly("Setting credentials in native keychain");
        const keychain = await this.requireKeychain();
        utils_1.logger.silly("Got native keychain reference");
        const MAX_SET_ATTEMPTS = 3;
        // Sometimes Keytar has a problem talking to the keychain on the OS. To be more resilient, we retry a few times.
        const setPasswordWithRetry = async (service, account, credentials) => {
            let attempts = 0;
            let error;
            while (attempts < MAX_SET_ATTEMPTS) {
                try {
                    utils_1.logger.silly("Attempting to set credentials");
                    await keychain.setPassword(service, account, credentials);
                    utils_1.logger.silly("Set credentials successfully");
                    return;
                }
                catch (error) {
                    error = error;
                    utils_1.logger.warn("Error attempting to set a credentials. Trying again... (" + attempts + ")");
                    utils_1.logger.warn(error);
                    attempts++;
                    await new Promise((resolve) => setTimeout(resolve, 200));
                }
            }
            throw error;
        };
        if (credentials.length > NativeCredentialsStore.KEYCHAIN_ENTRY_MAX_LENGTH) {
            utils_1.logger.silly("Credentials value is too long. Chunking it.");
            let index = 0;
            let chunk = 0;
            let hasNextChunk = true;
            while (hasNextChunk) {
                const credentialsChunk = credentials.substring(index, index + NativeCredentialsStore.KEYCHAIN_ENTRY_CHUNK_SIZE);
                index += NativeCredentialsStore.KEYCHAIN_ENTRY_CHUNK_SIZE;
                hasNextChunk = credentials.length - index > 0;
                const content = {
                    content: credentialsChunk,
                    hasNextChunk: hasNextChunk,
                };
                utils_1.logger.silly("Setting credentials chunk #" + chunk + " ...");
                await setPasswordWithRetry(service, chunk ? `${account}-${chunk}` : account, JSON.stringify(content));
                chunk++;
            }
        }
        else {
            await setPasswordWithRetry(service, account, credentials);
        }
    }
    async deletePassword(service, account) {
        utils_1.logger.silly("Deleting credentials from native keychain");
        const keychain = await this.requireKeychain();
        utils_1.logger.silly("Got native keychain reference");
        const didDelete = await keychain.deletePassword(service, account);
        utils_1.logger.silly("Deleted credentials from native keychain: " + didDelete);
        return didDelete;
    }
    async findPassword(service) {
        utils_1.logger.silly("Finding password in native keychain");
        const keychain = await this.requireKeychain();
        utils_1.logger.silly("Got native keychain reference");
        const credentials = await keychain.findPassword(service);
        utils_1.logger.silly("Got credentials from native keychain: " + (credentials ? "<hidden>" : "<empty>"));
        return credentials;
    }
    async findCredentials(service) {
        utils_1.logger.silly("Finding credentials in native keychain");
        const keychain = await this.requireKeychain();
        utils_1.logger.silly("Got native keychain reference");
        const credentials = await keychain.findCredentials(service);
        utils_1.logger.silly("Got credentials from native keychain: " + (credentials ? "<hidden>" : "<empty>"));
        return credentials;
    }
    clear() {
        utils_1.logger.silly("Clear native keychain");
        if (this.keychainCache instanceof InMemoryCredentialsStore) {
            utils_1.logger.silly("Clearing credentials from in-memory keychain");
            return this.keychainCache.clear();
        }
        // We don't know how to properly clear Keytar because we don't know
        // what services have stored credentials. For reference, a "service" is an extension.
        // TODO: should we clear credentials for the built-in auth extensions?
        return Promise.resolve();
    }
    async getSecretStoragePrefix() {
        return Promise.resolve(NativeCredentialsStore.KEYCHAIN_SERVICE);
    }
    async requireKeychain() {
        utils_1.logger.silly("Getting keychain reference");
        utils_1.logger.silly(`isKeychainEnabled: ${this.options.enabled}`);
        utils_1.logger.silly(`KeychainCache: ${this.keychainCache}`);
        if (this.keychainCache) {
            return this.keychainCache;
        }
        if (this.options.enabled === false) {
            utils_1.logger.silly("keychain is disabled. Using in-memory credential store instead.");
            this.keychainCache = new InMemoryCredentialsStore();
            return this.keychainCache;
        }
        try {
            utils_1.logger.silly("Attempting to load native keychain");
            await this.validateX11Environment();
            this.keychainCache = await Promise.resolve().then(() => __importStar(require("keytar")));
            // Try using keytar to see if it throws or not.
            await this.keychainCache.findCredentials("Out of the mountain of despair, a stone of hope");
        }
        catch (error) {
            throw error;
        }
        utils_1.logger.silly("Got native keychain reference");
        return this.keychainCache;
    }
    async validateX11Environment() {
        if (!(0, utils_1.isWSL)()) {
            // we assume that if we're not on WSL, we're on a sane environment
            // that has a valid X11 environment.
            return;
        }
        const { DISPLAY, WAYLAND_DISPLAY, MIR_SOCKET, WAYLAND_SOCKET } = process.env;
        let x11Host = DISPLAY || WAYLAND_DISPLAY || MIR_SOCKET || WAYLAND_SOCKET;
        const printX11ErrorAndExit = () => utils_1.logger.error(`An X11 server is required when keychain is enabled. You can disable keychain using --no-use-keychain or try a different login method.`, true);
        if (!x11Host) {
            utils_1.logger.error(`Environment variable DISPLAY is not set.`);
            printX11ErrorAndExit();
        }
        else {
            utils_1.logger.silly("X11 is set: " + x11Host);
            // An X11 address can be one of the following:
            //   - hostname:D.S means screen S on display D of host hostname; the X server for this display is listening at TCP port 6000+D.
            //   - host/unix:D.S means screen S on display D of host host; the X server for this display is listening at UNIX domain socket /tmp/.X11-unix/XD
            //     (so it's only reachable from host).
            //   - :D.S is equivalent to host/unix:D.S, where host is the local hostname.
            let [x11Hostname, x11Display] = x11Host.split(":");
            let x11Port = 6000;
            if (x11Display) {
                let [display, _screen] = x11Display.split(".");
                x11Port += parseInt(display, 10);
            }
            utils_1.logger.silly("X11 hostname: " + x11Hostname);
            if ((0, utils_1.isValidIpAddress)(x11Hostname)) {
                utils_1.logger.silly("X11 has a valid IP address");
            }
            else {
                x11Hostname = os_1.default.hostname();
                utils_1.logger.silly("X11 value is not a valid hostname. Forcing X11 host name to " + x11Hostname);
            }
            utils_1.logger.silly(`checking if X11 host ${x11Hostname}:${x11Port} is reachable. This may take a few seconds...`);
            try {
                await (0, wait_on_1.default)({
                    resources: ["tcp:" + x11Hostname + ":" + x11Port],
                    delay: 5000,
                    timeout: 10000, // 10 seconds
                });
            }
            catch (error) {
                utils_1.logger.error(`X11 host ${x11Hostname}:${x11Port} is not reachable.`);
                printX11ErrorAndExit();
            }
        }
    }
}
exports.NativeCredentialsStore = NativeCredentialsStore;
NativeCredentialsStore.KEYCHAIN_ENTRY_MAX_LENGTH = 2500;
NativeCredentialsStore.KEYCHAIN_ENTRY_CHUNK_SIZE = NativeCredentialsStore.KEYCHAIN_ENTRY_MAX_LENGTH - 100;
NativeCredentialsStore.KEYCHAIN_SERVICE = "swa-cli";
class InMemoryCredentialsStore {
    constructor() {
        this.secretVault = {};
    }
    async getPassword(service, account) {
        var _a, _b;
        utils_1.logger.silly("Getting password from in-memory keychain");
        return (_b = (_a = this.secretVault[service]) === null || _a === void 0 ? void 0 : _a[account]) !== null && _b !== void 0 ? _b : null;
    }
    async setPassword(service, account, credentials) {
        var _a;
        utils_1.logger.silly("Setting password in in-memory keychain");
        this.secretVault[service] = (_a = this.secretVault[service]) !== null && _a !== void 0 ? _a : {};
        this.secretVault[service][account] = credentials;
    }
    async deletePassword(service, account) {
        var _a;
        utils_1.logger.silly("Deleting password from in-memory keychain");
        if (!((_a = this.secretVault[service]) === null || _a === void 0 ? void 0 : _a[account])) {
            utils_1.logger.silly("Password not found in in-memory keychain");
            return false;
        }
        delete this.secretVault[service][account];
        if (Object.keys(this.secretVault[service]).length === 0) {
            delete this.secretVault[service];
        }
        utils_1.logger.silly("Password deleted from in-memory keychain");
        return true;
    }
    async findPassword(service) {
        var _a;
        utils_1.logger.silly("Finding password in in-memory keychain");
        return (_a = JSON.stringify(this.secretVault[service])) !== null && _a !== void 0 ? _a : null;
    }
    async findCredentials(service) {
        utils_1.logger.silly("Finding credentials in in-memory keychain");
        const credentials = [];
        for (const account of Object.keys(this.secretVault[service] || {})) {
            credentials.push({ account, password: this.secretVault[service][account] });
        }
        utils_1.logger.silly("Got credentials from native keychain: " + (credentials ? "<hidden>" : "<empty>"));
        return credentials;
    }
    async clear() {
        utils_1.logger.silly("Clearing in-memory keychain");
        this.secretVault = {};
    }
}
//# sourceMappingURL=credentials-store.js.map