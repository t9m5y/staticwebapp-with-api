"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoService = void 0;
const crypto_1 = __importDefault(require("crypto"));
const utils_1 = require("../../utils");
class CryptoService {
    constructor(machineId) {
        this.machineId = machineId;
        utils_1.logger.silly(`Invoking crypto service`);
    }
    getEncryption() {
        if (!this.encryption) {
            this.encryption = Promise.resolve({
                encrypt: (machineId, value) => {
                    return new Promise((resolve, reject) => {
                        try {
                            const iv = crypto_1.default.randomBytes(CryptoService.IV_LENGTH);
                            let cipher = crypto_1.default.createCipheriv(CryptoService.ALGORITHM, Buffer.from(machineId), iv);
                            let encrypted = cipher.update(value);
                            encrypted = Buffer.concat([encrypted, cipher.final()]);
                            const encryptedValue = iv.toString("hex") + ":" + encrypted.toString("hex");
                            resolve(encryptedValue);
                        }
                        catch (error) {
                            reject(error);
                        }
                    });
                },
                decrypt: (machineId, data) => {
                    return new Promise((resolve, reject) => {
                        try {
                            let dataSegments = data.includes(":") ? data.split(":") : [];
                            let iv = Buffer.from(dataSegments.shift() || "", "hex");
                            let encryptedText = Buffer.from(dataSegments.join(":"), "hex");
                            let decipher = crypto_1.default.createDecipheriv(CryptoService.ALGORITHM, Buffer.from(machineId), iv);
                            let decrypted = decipher.update(encryptedText);
                            decrypted = Buffer.concat([decrypted, decipher.final()]);
                            resolve(decrypted.toString());
                        }
                        catch (error) {
                            reject(error);
                        }
                    });
                },
            });
        }
        return this.encryption;
    }
    async encrypt(value) {
        utils_1.logger.silly(`Encrypting credentials`);
        try {
            const encryption = await this.getEncryption();
            return encryption.encrypt(this.machineId, value);
        }
        catch (error) {
            utils_1.logger.warn(`Failed to encrypt credentials: ${error.message}`);
            return value;
        }
    }
    async decrypt(value) {
        utils_1.logger.silly(`Decrypting credentials`);
        try {
            const encryption = await this.getEncryption();
            return encryption.decrypt(this.machineId, value);
        }
        catch (error) {
            utils_1.logger.warn(`Failed to decrypt credentials: ${error.message}`);
            return value;
        }
    }
}
exports.CryptoService = CryptoService;
CryptoService.IV_LENGTH = 16; // For AES, this is always 16
CryptoService.ALGORITHM = "aes-256-cbc";
//# sourceMappingURL=crypto.js.map