"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SWACLIPersistenceCachePlugin = void 0;
const utils_1 = require("../utils");
const azure_environment_1 = require("./impl/azure-environment");
const credentials_store_1 = require("./impl/credentials-store");
const crypto_1 = require("./impl/crypto");
const machine_identifier_1 = require("./impl/machine-identifier");
const secret_storage_1 = require("./impl/secret-storage");
/**
 * SWA CLI cache plugin which enables callers to write the MSAL cache to disk on Windows,
 * macOs, and Linux using native keychain.
 */
class SWACLIPersistenceCachePlugin {
    constructor(options) {
        this.options = options;
    }
    /**
     * Reads from storage and saves an in-memory copy. If keychain has not been updated
     * since last time data was read, in memory copy is used.
     *
     * If cacheContext.cacheHasChanged === true, then file lock is created and not deleted until
     * afterCacheAccess() is called, to prevent the cache file from changing in between
     * beforeCacheAccess() and afterCacheAccess().
     */
    async beforeCacheAccess(cacheContext) {
        utils_1.logger.silly(`Executing before cache access plugin`);
        const machineId = await (0, machine_identifier_1.getMachineId)();
        utils_1.logger.silly(`Machine ID: ${machineId ? "<hidden>" : "<empty>"}`);
        const secretStorage = new secret_storage_1.SecretStorage(this.options, new credentials_store_1.NativeCredentialsStore(this.options), new crypto_1.CryptoService(machineId));
        const cachedValue = await secretStorage.getCredentials(machineId, azure_environment_1.Environment.AzureCloud.name);
        utils_1.logger.silly(`Credentials: ${cachedValue ? "<hidden>" : "<empty>"}`);
        cachedValue && cacheContext.tokenCache.deserialize(cachedValue);
        utils_1.logger.silly(`Before cache access plugin. Done.`);
    }
    /**
     * Writes to storage if MSAL in memory copy of cache has been changed.
     */
    async afterCacheAccess(cacheContext) {
        utils_1.logger.silly(`Executing after cache access plugin`);
        const machineId = await (0, machine_identifier_1.getMachineId)();
        utils_1.logger.silly(`Machine ID: ${machineId ? "<hidden>" : "<empty>"}`);
        const secretStorage = new secret_storage_1.SecretStorage(this.options, new credentials_store_1.NativeCredentialsStore(this.options), new crypto_1.CryptoService(machineId));
        utils_1.logger.silly(`Did TokenCacheContext cache changed: ${cacheContext.cacheHasChanged}`);
        if (cacheContext.cacheHasChanged) {
            await secretStorage.setCredentials(machineId, azure_environment_1.Environment.AzureCloud.name, cacheContext.tokenCache.serialize());
        }
        utils_1.logger.silly(`After cache access plugin. Done.`);
    }
    /**
     * Clears credentials cache.
     */
    async clearCache() {
        utils_1.logger.silly(`Clearing credentials cache`);
        const machineId = await (0, machine_identifier_1.getMachineId)();
        utils_1.logger.silly(`Machine ID: ${machineId ? "<hidden>" : "<empty>"}`);
        const secretStorage = new secret_storage_1.SecretStorage(this.options, new credentials_store_1.NativeCredentialsStore(this.options), new crypto_1.CryptoService(machineId));
        await secretStorage.deleteCredentials(machineId, azure_environment_1.Environment.AzureCloud.name);
        utils_1.logger.silly(`Credentials cache cleared`);
    }
}
exports.SWACLIPersistenceCachePlugin = SWACLIPersistenceCachePlugin;
//# sourceMappingURL=persistence-cache-plugin.js.map