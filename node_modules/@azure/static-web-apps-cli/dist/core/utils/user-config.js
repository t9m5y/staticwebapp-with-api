"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSWAConfigFileUrl = exports.validateUserWorkflowConfig = exports.validateRuntimeConfigAndGetData = exports.findSWAConfigFile = exports.traverseFolder = void 0;
const ajv_draft_04_1 = __importDefault(require("ajv-draft-04"));
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = __importDefault(require("fs"));
const json_source_map_1 = __importDefault(require("json-source-map"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const path_1 = __importDefault(require("path"));
const constants_1 = require("../constants");
const logger_1 = require("./logger");
const net_1 = require("./net");
const { readdir, readFile, stat } = fs_1.default.promises;
/**
 * A utility function to recursively traverse a folder and returns its entries.
 * @param folder The folder to traverse.
 * @returns A Generator object that yields entry paths.
 * @example
 * ```
 * for await (const file of traverseFolder(folder)) {
 *    console.log(file);
 * }
 * ```
 */
async function* traverseFolder(folder) {
    const folders = (await readdir(folder, { withFileTypes: true }));
    for (const folderEntry of folders) {
        // WARNING: ignore node_modules and other common folders to avoid perf hits!
        if (folderEntry.name.includes("node_modules") || folderEntry.name.startsWith(".git")) {
            continue;
        }
        const entryPath = path_1.default.resolve(folder, folderEntry.name);
        if (folderEntry.isDirectory()) {
            yield* traverseFolder(entryPath);
        }
        else {
            yield entryPath;
        }
    }
}
exports.traverseFolder = traverseFolder;
/**
 * Find the `staticwebapp.config.json` (or `routes.json`) configuration file in a specific folder.
 * @param folder The folder where to lookup for the configuration file.
 * @returns `staticwebapp.config.json` if it was found, or fallback to `routes.json`. Return `null` if none were found.
 */
async function findSWAConfigFile(folder) {
    const configFiles = new Map();
    for await (const filepath of traverseFolder(folder)) {
        const filename = path_1.default.basename(filepath);
        if (filename === constants_1.SWA_CONFIG_FILENAME || filename === constants_1.SWA_CONFIG_FILENAME_LEGACY) {
            const isLegacyConfigFile = filename === constants_1.SWA_CONFIG_FILENAME_LEGACY;
            configFiles.set(filename, { filepath, isLegacyConfigFile });
        }
    }
    // take staticwebapp.config.json if it exists
    if (configFiles.has(constants_1.SWA_CONFIG_FILENAME)) {
        const file = configFiles.get(constants_1.SWA_CONFIG_FILENAME);
        if (file) {
            const content = await validateRuntimeConfigAndGetData(file.filepath);
            if (content) {
                const fileSize = (await stat(file.filepath)).size;
                const fileSizeInKb = Math.round(fileSize / 1024);
                if (fileSizeInKb > constants_1.SWA_RUNTIME_CONFIG_MAX_SIZE_IN_KB) {
                    logger_1.logger.warn(`WARNING: ${constants_1.SWA_CONFIG_FILENAME} is ${fileSizeInKb} bytes. The maximum size is ${constants_1.SWA_RUNTIME_CONFIG_MAX_SIZE_IN_KB} bytes.`);
                }
                logger_1.logger.silly(`Content parsed successfully`);
                logger_1.logger.log(`\nFound configuration file:\n  ${chalk_1.default.green(file.filepath)}\n`);
                return {
                    filepath: file.filepath,
                    content,
                };
            }
        }
        return null;
    }
    // legacy config file detected. Warn and return null.
    if (configFiles.has(constants_1.SWA_CONFIG_FILENAME_LEGACY)) {
        const file = configFiles.get(constants_1.SWA_CONFIG_FILENAME_LEGACY);
        logger_1.logger.warn(`Found legacy configuration file: ${file === null || file === void 0 ? void 0 : file.filepath}.`);
        logger_1.logger.warn(`   WARNING: Functionality defined in the routes.json file is now deprecated. File will be ignored!\n` +
            `   Read more: https://docs.microsoft.com/azure/static-web-apps/configuration#routes`);
        return null;
    }
    // no config file found
    logger_1.logger.silly(`No ${constants_1.SWA_CONFIG_FILENAME} found in current project`);
    return null;
}
exports.findSWAConfigFile = findSWAConfigFile;
async function validateRuntimeConfigAndGetData(filepath) {
    const ajv4 = new ajv_draft_04_1.default({
        strict: false,
        allErrors: true,
    });
    logger_1.logger.silly(`Loading staticwebapp.config.json schema...`);
    const schema = await loadSWAConfigSchema();
    if (!schema) {
        logger_1.logger.warn(`WARNING: Failed to load staticwebapp.config.json schema. Continuing without validation!`);
        return null;
    }
    logger_1.logger.silly(`Compiling schema...`);
    const validate = ajv4.compile(schema);
    logger_1.logger.silly(`Reading content from staticwebapp.config.json...`);
    const content = (await readFile(filepath)).toString("utf-8");
    let config;
    try {
        logger_1.logger.silly(`Parsing staticwebapp.config.json...`);
        config = JSON.parse(content);
    }
    catch (err) {
        printJSONValidationWarnings(filepath, content, err.message);
        return null;
    }
    logger_1.logger.silly(`Validating staticwebapp.config.json...`);
    const isValidSWAConfigFile = validate(config);
    if (!isValidSWAConfigFile) {
        printSchemaValidationWarnings(filepath, config, validate);
        return null;
    }
    logger_1.logger.silly(`File validated successfully. Continuing with configuration!`);
    return config;
}
exports.validateRuntimeConfigAndGetData = validateRuntimeConfigAndGetData;
function findLineAndColumnByPosition(content, position) {
    const notFound = { line: -1, column: -1 };
    if (!position) {
        return notFound;
    }
    const lines = content.split("\n");
    for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
        const line = lines[lineIndex];
        const lineChars = line.split("");
        const lineLength = lineChars.length;
        for (let columnIndex = 0; columnIndex <= lineLength; columnIndex++) {
            // decrement position by 1 until we reach 0
            position--;
            // if position is 0, then we found the line
            if (position === 0) {
                return {
                    line: lineIndex,
                    column: columnIndex,
                };
            }
        }
    }
    return notFound;
}
async function loadSWAConfigSchema() {
    const schemaUrl = "https://json.schemastore.org/staticwebapp.config.json";
    try {
        const res = await (0, node_fetch_1.default)(schemaUrl, { timeout: 10 * 1000 });
        if (res.status === 200) {
            logger_1.logger.silly(`Schema loaded successfully from ${schemaUrl}`);
            return (await res.json());
        }
    }
    catch { }
    logger_1.logger.silly(`Failed to load schema from ${schemaUrl}`);
    return null;
}
/**
 * Valide and normalize all paths of a workflow confifuration.
 * @param userWorkflowConfig The project workflow configuration.
 * @returns A configuration object.
 */
function validateUserWorkflowConfig(userWorkflowConfig) {
    let appLocation = undefined;
    let apiLocation = undefined;
    let outputLocation = undefined;
    logger_1.logger.silly(`Validating user workflow config (BEFORE):`);
    logger_1.logger.silly(userWorkflowConfig);
    if (userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.appLocation) {
        appLocation = path_1.default.resolve(userWorkflowConfig.appLocation);
        if (path_1.default.isAbsolute(userWorkflowConfig.appLocation)) {
            appLocation = userWorkflowConfig.appLocation;
        }
    }
    if (userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.apiLocation) {
        if ((0, net_1.isHttpUrl)(userWorkflowConfig.apiLocation)) {
            apiLocation = userWorkflowConfig.apiLocation;
        }
        else {
            // use the user's config and construct an absolute path
            apiLocation = path_1.default.resolve(userWorkflowConfig.apiLocation);
        }
        if (path_1.default.isAbsolute(userWorkflowConfig.apiLocation)) {
            apiLocation = userWorkflowConfig.apiLocation;
        }
    }
    if (userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.outputLocation) {
        // is dev server url?
        if ((0, net_1.isHttpUrl)(userWorkflowConfig.outputLocation)) {
            outputLocation = userWorkflowConfig.outputLocation;
        }
        else {
            outputLocation = path_1.default.resolve(userWorkflowConfig.outputLocation);
            if (path_1.default.isAbsolute(userWorkflowConfig.outputLocation)) {
                outputLocation = userWorkflowConfig.outputLocation;
            }
        }
    }
    logger_1.logger.silly(`Validating user workflow config (AFTER):`);
    logger_1.logger.silly({
        appLocation,
        apiLocation,
        outputLocation,
    });
    return {
        appLocation,
        apiLocation,
        outputLocation,
    };
}
exports.validateUserWorkflowConfig = validateUserWorkflowConfig;
/**
 * Check if an HTTP request path contains `staticwebapp.config.json`
 * @param req Node.js HTTP request object.
 * @returns True if the request is accessing the configuration file. False otherwise.
 */
function isSWAConfigFileUrl(req) {
    var _a, _b;
    return ((_a = req.url) === null || _a === void 0 ? void 0 : _a.endsWith(`/${constants_1.SWA_CONFIG_FILENAME}`)) || ((_b = req.url) === null || _b === void 0 ? void 0 : _b.endsWith(`/${constants_1.SWA_CONFIG_FILENAME_LEGACY}`));
}
exports.isSWAConfigFileUrl = isSWAConfigFileUrl;
function printJSONValidationWarnings(filepath, data, errorMessage) {
    var _a, _b;
    logger_1.logger.warn(`WARNING: Failed to read staticwebapp.config.json configuration from:\n   ${filepath}\n`);
    logger_1.logger.error(`The following error was encountered: ${errorMessage}`);
    if (errorMessage.includes("Unexpected token")) {
        // extract the position of the error
        let [_, position] = (_b = (_a = errorMessage.match(/in JSON at position (\d+)/)) === null || _a === void 0 ? void 0 : _a.map(Number)) !== null && _b !== void 0 ? _b : [undefined, undefined];
        const lines = data.split("\n");
        const lineAndColumn = findLineAndColumnByPosition(data, position);
        const lineIndex = lineAndColumn.line;
        if (lineIndex !== -1) {
            let errorMessage = "";
            const errorOffsetLines = 2;
            const startLine = Math.max(lineIndex - errorOffsetLines, 0);
            const endLine = Math.min(lineIndex + errorOffsetLines, lines.length);
            for (let index = startLine; index < endLine; index++) {
                const line = lines[index];
                if (index === lineIndex) {
                    errorMessage += chalk_1.default.bgRedBright(chalk_1.default.grey(`${index + 1}:`) + ` ${line}\n`);
                }
                else {
                    errorMessage += chalk_1.default.grey(`${index + 1}:`) + ` ${line}\n`;
                }
            }
            logger_1.logger.warn(errorMessage);
        }
    }
    logger_1.logger.warn(`Please fix the above error and try again to load and use the configuration.`);
    logger_1.logger.warn(`Read more: https://aka.ms/swa/config-schema`);
}
function printSchemaValidationWarnings(filepath, data, validator) {
    var _a, _b, _c;
    let sourceCodeWhereErrorHappened = "";
    const sourceMap = json_source_map_1.default.stringify(data, null, 4);
    const jsonLines = sourceMap.json.split("\n");
    const error = (_a = validator.errors) === null || _a === void 0 ? void 0 : _a[0];
    const errorOffsetLines = 2;
    // show only one error at a time
    if (error) {
        let errorPointer = sourceMap.pointers[error.instancePath];
        logger_1.logger.silly({ errorPointer, error });
        let startLine = Math.max(errorPointer.value.line - errorOffsetLines, 0);
        const endLine = Math.min(errorPointer.valueEnd.line + errorOffsetLines, jsonLines.length);
        for (let index = startLine; index < endLine; index++) {
            const line = jsonLines[index];
            const isOneLine = errorPointer.value.line === errorPointer.valueEnd.line;
            const lineHasError = error.params.additionalProperty && ((_b = line.match(error.params.additionalProperty)) === null || _b === void 0 ? void 0 : _b.length);
            let shouldHighlightLine = (isOneLine && index === errorPointer.value.line) || lineHasError;
            if (error.params.missingProperty) {
                // special case to highlight object where the property is missing
                shouldHighlightLine = index >= errorPointer.value.line && index <= errorPointer.valueEnd.line;
            }
            if (shouldHighlightLine) {
                // highlight the line where the error happened
                sourceCodeWhereErrorHappened += chalk_1.default.bgRedBright(chalk_1.default.grey(`${index}:`) + ` ${line}\n`);
            }
            else {
                sourceCodeWhereErrorHappened += chalk_1.default.grey(`${index}:`) + ` ${line}\n`;
            }
        }
        logger_1.logger.warn(`WARNING: Failed to read staticwebapp.config.json configuration from:\n   ${filepath}\n`);
        let errorMessage = (_c = error === null || error === void 0 ? void 0 : error.message) !== null && _c !== void 0 ? _c : "Unknown error";
        switch (error === null || error === void 0 ? void 0 : error.keyword) {
            case "enum":
                errorMessage = (error === null || error === void 0 ? void 0 : error.message) + " " + error.params.allowedValues.join(", ");
                break;
            case "type":
                errorMessage = error === null || error === void 0 ? void 0 : error.message;
                break;
            case "required":
                errorMessage = `The property "${error === null || error === void 0 ? void 0 : error.params.missingProperty}" is required.`;
                break;
            case "additionalProperties":
                errorMessage = `The property "${error.params.additionalProperty}" is not allowed (Line: ${startLine})`;
                break;
            //TODO: add more cases
        }
        logger_1.logger.warn(`The following error was encountered: ${errorMessage}`);
        logger_1.logger.warn(sourceCodeWhereErrorHappened);
        logger_1.logger.warn(`Please fix the above error and try again to load and use the configuration.`);
        logger_1.logger.warn(`Read more: https://aka.ms/swa/config-schema`);
    }
}
//# sourceMappingURL=user-config.js.map