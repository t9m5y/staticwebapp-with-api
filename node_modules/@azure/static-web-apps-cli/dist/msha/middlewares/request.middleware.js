"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.requestMiddleware = exports.handleUserConfig = exports.onConnectionLost = void 0;
const chalk_1 = __importDefault(require("chalk"));
const finalhandler_1 = __importDefault(require("finalhandler"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const serve_static_1 = __importDefault(require("serve-static"));
const config_1 = require("../../config");
const core_1 = require("../../core");
const constants_1 = require("../../core/constants");
const auth_handler_1 = require("../handlers/auth.handler");
const error_page_handler_1 = require("../handlers/error-page.handler");
const function_handler_1 = require("../handlers/function.handler");
const routes_engine_1 = require("../routes-engine");
const route_processor_1 = require("../routes-engine/route-processor");
const response_middleware_1 = require("./response.middleware");
/**
 * On connection lost handler. Called when a connection to a target host cannot be made or if the remote target is down.
 * @param req Node.js HTTP request object.
 * @param res Node.js HTTP response object.
 * @param target The HTTP host target.
 * @returns A callback function including an Error object.
 */
function onConnectionLost(req, res, target, prefix = "") {
    prefix = prefix === "" ? prefix : ` ${prefix} `;
    return (error) => {
        if (error.message.includes("ECONNREFUSED")) {
            const statusCode = 502;
            res.statusCode = statusCode;
            const uri = `${target}${req.url}`;
            core_1.logger.error(`${prefix}${req.method} ${uri} - ${statusCode} (Bad Gateway)`);
        }
        else {
            core_1.logger.error(`${error.message}`);
        }
        core_1.logger.silly({ error });
        res.end();
    };
}
exports.onConnectionLost = onConnectionLost;
/**
 *
 * @param appLocation The location of the application code, where the application configuration file is located.
 * @returns The JSON content of the application configuration file defined in the `staticwebapp.config.json` file (or legacy file `routes.json`).
 * If no configuration file is found, returns `undefined`.
 * @see https://docs.microsoft.com/azure/static-web-apps/configuration
 */
async function handleUserConfig(appLocation) {
    if (!appLocation || !fs_1.default.existsSync(appLocation)) {
        return;
    }
    const runtimeConfigContent = await (0, core_1.findSWAConfigFile)(appLocation);
    if (!runtimeConfigContent) {
        return;
    }
    return runtimeConfigContent.content;
}
exports.handleUserConfig = handleUserConfig;
/**
 * Serves static content or proxy requests to a static dev server (when used).
 * @param req Node.js HTTP request object.
 * @param res Node.js HTTP response object.
 * @param proxyApp An `http-proxy` instance.
 * @param target The root folder of the static app (ie. `output_location`). Or, the HTTP host target, if connecting to a dev server, or
 */
function serveStaticOrProxyResponse(req, res, proxyApp, target) {
    var _a, _b;
    if ([301, 302].includes(res.statusCode)) {
        res.end();
        return;
    }
    const customUrl = (0, route_processor_1.isCustomUrl)(req);
    core_1.logger.silly(`customUrl: ${chalk_1.default.yellow(customUrl)}`);
    if (((_a = req.url) === null || _a === void 0 ? void 0 : _a.includes("index.html")) || customUrl) {
        // serve index.html or custom pages from user's `outputLocation`
        core_1.logger.silly(`custom page or index.html detected`);
        // extract user custom page filename
        req.url = (_b = req.url) === null || _b === void 0 ? void 0 : _b.replace(constants_1.CUSTOM_URL_SCHEME, "");
        target = config_1.DEFAULT_CONFIG.outputLocation;
        core_1.logger.silly(` - url: ${chalk_1.default.yellow(req.url)}`);
        core_1.logger.silly(` - statusCode: ${chalk_1.default.yellow(res.statusCode)}`);
        core_1.logger.silly(` - target: ${chalk_1.default.yellow(target)}`);
    }
    const is4xx = res.statusCode >= 400 && res.statusCode < 500;
    core_1.logger.silly(`is4xx: ${is4xx}`);
    // if the static app is served by a dev server, forward all requests to it.
    if ((0, constants_1.IS_APP_DEV_SERVER)() && (!is4xx || customUrl)) {
        core_1.logger.silly(`remote dev server detected. Proxying request`);
        core_1.logger.silly(` - url: ${chalk_1.default.yellow(req.url)}`);
        core_1.logger.silly(` - code: ${chalk_1.default.yellow(res.statusCode)}`);
        target = config_1.DEFAULT_CONFIG.outputLocation;
        (0, core_1.logRequest)(req, target);
        proxyApp.web(req, res, {
            target,
            secure: false,
            toProxy: true,
        }, onConnectionLost(req, res, target));
        proxyApp.once("proxyRes", (proxyRes) => {
            core_1.logger.silly(`getting response from dev server`);
            (0, core_1.logRequest)(req, target, proxyRes.statusCode);
        });
    }
    else {
        // not a dev server
        // run one last check before serving the page:
        // if the requested file is not found on disk
        // send our SWA 404 default page instead of serve-static's one.
        let file = null;
        let fileInOutputLocation = null;
        let existsInOutputLocation = false;
        target = config_1.DEFAULT_CONFIG.outputLocation;
        if (target) {
            fileInOutputLocation = path_1.default.join(target, req.url);
            existsInOutputLocation = fs_1.default.existsSync(fileInOutputLocation);
            core_1.logger.silly(`checking if file exists in user's output location`);
            core_1.logger.silly(` - file: ${chalk_1.default.yellow(fileInOutputLocation)}`);
            core_1.logger.silly(` - exists: ${chalk_1.default.yellow(existsInOutputLocation)}`);
        }
        if (existsInOutputLocation === false) {
            // file doesn't exist in the user's `outputLocation`
            // check in the cli public dir
            target = constants_1.SWA_PUBLIC_DIR;
            core_1.logger.silly(`checking if file exists in CLI public dir`);
            const fileInCliPublicDir = path_1.default.join(target, req.url);
            const existsInCliPublicDir = fs_1.default.existsSync(fileInCliPublicDir);
            core_1.logger.silly(` - file: ${chalk_1.default.yellow(fileInCliPublicDir)}`);
            core_1.logger.silly(` - exists: ${chalk_1.default.yellow(existsInCliPublicDir)}`);
            if (existsInCliPublicDir === false) {
                req.url = "/404.html";
                res.statusCode = 404;
                target = constants_1.SWA_PUBLIC_DIR;
            }
            else {
                file = fileInCliPublicDir;
            }
        }
        else {
            file = fileInOutputLocation;
        }
        core_1.logger.silly(`serving static content`);
        core_1.logger.silly({ file, url: req.url, code: res.statusCode });
        const onerror = (err) => console.error(err);
        const done = (0, finalhandler_1.default)(req, res, { onerror });
        // serving static content is only possible for GET requests
        req.method = "GET";
        (0, serve_static_1.default)(target, { extensions: ["html"] })(req, res, done);
    }
}
/**
 * This functions runs a series of heuristics to determines if a request is a Websocket request.
 * @param req Node.js HTTP request object.
 * @returns True if the request is a Websocket request. False otherwise.
 */
function isWebsocketRequest(req) {
    var _a, _b;
    // TODO: find a better way of guessing if this is a Websocket request
    const isSockJs = (_a = req.url) === null || _a === void 0 ? void 0 : _a.includes("sockjs-node");
    const hasWebsocketHeader = ((_b = req.headers.upgrade) === null || _b === void 0 ? void 0 : _b.toLowerCase()) === "websocket";
    return isSockJs || hasWebsocketHeader;
}
/**
 *
 * @param req Node.js HTTP request object.
 * @param res Node.js HTTP response object.
 * @param proxyApp An `http-proxy` instance.
 * @param userConfig The application configuration file defined in the `staticwebapp.config.json` file (or legacy file `routes.json`).
 * @returns This middleware mutates the `req` and `res` HTTP objects.
 */
async function requestMiddleware(req, res, proxyApp, userConfig) {
    if (!req.url) {
        return;
    }
    core_1.logger.silly(``);
    core_1.logger.silly(`--------------------------------------------------------`);
    core_1.logger.silly(`------------------- processing route -------------------`);
    core_1.logger.silly(`--------------------------------------------------------`);
    core_1.logger.silly(`processing ${chalk_1.default.yellow(req.url)}`);
    if (isWebsocketRequest(req)) {
        core_1.logger.silly(`websocket request detected`);
        return serveStaticOrProxyResponse(req, res, proxyApp, config_1.DEFAULT_CONFIG.outputLocation);
    }
    let target = config_1.DEFAULT_CONFIG.outputLocation;
    core_1.logger.silly(`checking for matching route`);
    const matchingRouteRule = (0, routes_engine_1.tryGetMatchingRoute)(req, userConfig);
    if (matchingRouteRule) {
        core_1.logger.silly({ matchingRouteRule });
        const statusCodeToServe = parseInt(`${matchingRouteRule === null || matchingRouteRule === void 0 ? void 0 : matchingRouteRule.statusCode}`, 10);
        if ([404, 403, 401].includes(statusCodeToServe)) {
            core_1.logger.silly(` - ${statusCodeToServe} code detected. Exit`);
            (0, error_page_handler_1.handleErrorPage)(req, res, statusCodeToServe, userConfig === null || userConfig === void 0 ? void 0 : userConfig.responseOverrides);
            return serveStaticOrProxyResponse(req, res, proxyApp, target);
        }
    }
    let authStatus = constants_1.AUTH_STATUS.NoAuth;
    const isAuthReq = (0, auth_handler_1.isAuthRequest)(req);
    core_1.logger.silly(`checking auth request`);
    if (isAuthReq) {
        core_1.logger.silly(` - auth request detected`);
        return await (0, auth_handler_1.handleAuthRequest)(req, res, matchingRouteRule, userConfig);
    }
    else {
        core_1.logger.silly(` - not an auth request`);
    }
    core_1.logger.silly(`checking function request`);
    const isFunctionReq = (0, function_handler_1.isFunctionRequest)(req, matchingRouteRule === null || matchingRouteRule === void 0 ? void 0 : matchingRouteRule.rewrite);
    if (!isFunctionReq) {
        core_1.logger.silly(` - not a function request`);
    }
    if (!(0, routes_engine_1.isRequestMethodValid)(req, isFunctionReq, isAuthReq)) {
        res.statusCode = 405;
        return res.end();
    }
    core_1.logger.silly(`checking for query params`);
    const { urlPathnameWithoutQueryParams, url, urlPathnameWithQueryParams } = (0, route_processor_1.parseQueryParams)(req, matchingRouteRule);
    core_1.logger.silly(`checking rewrite auth login request`);
    if (urlPathnameWithQueryParams && (0, auth_handler_1.isLoginRequest)(urlPathnameWithoutQueryParams)) {
        core_1.logger.silly(` - auth login dectected`);
        authStatus = constants_1.AUTH_STATUS.HostNameAuthLogin;
        req.url = url.toString();
        return await (0, auth_handler_1.handleAuthRequest)(req, res, matchingRouteRule, userConfig);
    }
    core_1.logger.silly(`checking rewrite auth logout request`);
    if (urlPathnameWithQueryParams && (0, auth_handler_1.isLogoutRequest)(urlPathnameWithoutQueryParams)) {
        core_1.logger.silly(` - auth logout dectected`);
        authStatus = constants_1.AUTH_STATUS.HostNameAuthLogout;
        req.url = url.toString();
        return await (0, auth_handler_1.handleAuthRequest)(req, res, matchingRouteRule, userConfig);
    }
    if (!(0, routes_engine_1.isRouteRequiringUserRolesCheck)(req, matchingRouteRule, isFunctionReq, authStatus)) {
        (0, error_page_handler_1.handleErrorPage)(req, res, 401, userConfig === null || userConfig === void 0 ? void 0 : userConfig.responseOverrides);
        return serveStaticOrProxyResponse(req, res, proxyApp, target);
    }
    if (authStatus != constants_1.AUTH_STATUS.NoAuth && (authStatus != constants_1.AUTH_STATUS.HostNameAuthLogin || !urlPathnameWithQueryParams)) {
        if (authStatus == constants_1.AUTH_STATUS.HostNameAuthLogin && matchingRouteRule) {
            return (0, auth_handler_1.getAuthBlockResponse)(req, res, userConfig, matchingRouteRule);
        }
        return await (0, auth_handler_1.handleAuthRequest)(req, res, matchingRouteRule, userConfig);
    }
    if (!(0, response_middleware_1.getResponse)(req, res, matchingRouteRule, userConfig, isFunctionReq)) {
        core_1.logger.silly(` - url: ${chalk_1.default.yellow(req.url)}`);
        core_1.logger.silly(` - target: ${chalk_1.default.yellow(target)}`);
        serveStaticOrProxyResponse(req, res, proxyApp, target);
    }
}
exports.requestMiddleware = requestMiddleware;
//# sourceMappingURL=request.middleware.js.map