"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getStorageContent = exports.getResponse = void 0;
const chalk_1 = __importDefault(require("chalk"));
const core_1 = require("../../core");
const constants_1 = require("../../core/constants");
const error_page_handler_1 = require("../handlers/error-page.handler");
const function_handler_1 = require("../handlers/function.handler");
const routes_engine_1 = require("../routes-engine");
const route_processor_1 = require("../routes-engine/route-processor");
function getResponse(req, res, matchedRoute, userConfig, isFunctionRequest) {
    const statusCodeToServe = parseInt(`${matchedRoute === null || matchedRoute === void 0 ? void 0 : matchedRoute.statusCode}`, 10);
    const redirect = matchedRoute === null || matchedRoute === void 0 ? void 0 : matchedRoute.redirect;
    const rewrite = matchedRoute === null || matchedRoute === void 0 ? void 0 : matchedRoute.rewrite;
    core_1.logger.silly(`using userConfig`);
    core_1.logger.silly({ userConfig });
    if (redirect) {
        core_1.logger.silly(` - redirect rule detected. Exit`);
        (0, routes_engine_1.applyRedirectResponse)(req, res, matchedRoute);
        return false;
    }
    // We should always set the x-ms-original-url to be the full request URL.
    req.headers["x-ms-original-url"] = new URL(req.url, `http://${req.headers.host}`).href;
    if (rewrite) {
        req.url = rewrite;
    }
    if ([403, 401].includes(statusCodeToServe)) {
        core_1.logger.silly(` - ${statusCodeToServe} code detected. Exit`);
        (0, error_page_handler_1.handleErrorPage)(req, res, statusCodeToServe, userConfig === null || userConfig === void 0 ? void 0 : userConfig.responseOverrides);
        return false;
    }
    if (isFunctionRequest) {
        (0, function_handler_1.handleFunctionRequest)(req, res);
        return true;
    }
    const storageResult = getStorageContent(req, res, rewrite, matchedRoute, userConfig === null || userConfig === void 0 ? void 0 : userConfig.responseOverrides, userConfig === null || userConfig === void 0 ? void 0 : userConfig.navigationFallback, userConfig === null || userConfig === void 0 ? void 0 : userConfig.mimeTypes, matchedRoute === null || matchedRoute === void 0 ? void 0 : matchedRoute.headers, userConfig === null || userConfig === void 0 ? void 0 : userConfig.globalHeaders);
    if (storageResult.isFunctionFallbackRequest) {
        req.url = userConfig === null || userConfig === void 0 ? void 0 : userConfig.navigationFallback.rewrite;
        (0, function_handler_1.handleFunctionRequest)(req, res);
        return true;
    }
    if (statusCodeToServe) {
        res.statusCode = statusCodeToServe;
    }
    return false;
}
exports.getResponse = getResponse;
function getStorageContent(req, res, pathToServe, matchedRoute, responseOverridesRule, navigationFallbackRule, mimeTypeRule, routeHeaders, globalHeaders) {
    core_1.logger.silly(`checking storage content`);
    // don't serve staticwebapp.config.json / routes.json
    if ((0, core_1.isSWAConfigFileUrl)(req)) {
        core_1.logger.silly(` - request to config file detected. Exit`);
        (0, error_page_handler_1.handleErrorPage)(req, res, 404, responseOverridesRule);
        return {
            isFunctionFallbackRequest: false,
            isSuccessfulSiteHit: false,
        };
    }
    let requestPath = req.url;
    let filePathFromRequest = null;
    let decodedRequestPath = req.url;
    const { urlPathnameWithoutQueryParams } = (0, route_processor_1.parseQueryParams)(req, matchedRoute);
    // we only process if the user is NOT connecting to a remote dev server.
    // if the user is connecting to a remote dev server, we skip the following logic.
    if ((0, constants_1.IS_APP_DEV_SERVER)()) {
        core_1.logger.silly(`remote dev server detected.`);
        return {
            isFunctionFallbackRequest: false,
            isSuccessfulSiteHit: true,
        };
    }
    else {
        requestPath = urlPathnameWithoutQueryParams;
        decodedRequestPath = urlPathnameWithoutQueryParams;
        if (pathToServe) {
            requestPath = pathToServe;
            decodedRequestPath = decodeURI(pathToServe);
        }
        filePathFromRequest = (0, routes_engine_1.tryFindFileForRequest)(requestPath);
    }
    if (!filePathFromRequest) {
        let shouldDisplayNotFoundPage = true;
        if (navigationFallbackRule === null || navigationFallbackRule === void 0 ? void 0 : navigationFallbackRule.rewrite) {
            const isFunctionFallback = (0, function_handler_1.isFunctionRequest)(req, navigationFallbackRule.rewrite);
            core_1.logger.silly(` - isFunctionFallback: ${chalk_1.default.yellow(isFunctionFallback)}`);
            if (isFunctionFallback) {
                return {
                    isFunctionFallbackRequest: true,
                    isSuccessfulSiteHit: false,
                };
            }
            else {
                const navigationFallbackRewrite = navigationFallbackRule.rewrite;
                core_1.logger.silly(`validating navigation fallback rewrite rule`);
                core_1.logger.silly(` - rewrite: ${chalk_1.default.yellow(navigationFallbackRewrite)}`);
                const isNavigationFallbackWritePathExists = (0, routes_engine_1.tryFindFileForRequest)(navigationFallbackRewrite);
                if (isNavigationFallbackWritePathExists &&
                    !(0, routes_engine_1.isRequestPathExcludedFromNavigationFallback)(decodedRequestPath, navigationFallbackRule, matchedRoute)) {
                    shouldDisplayNotFoundPage = false;
                }
                if (navigationFallbackRewrite) {
                    filePathFromRequest = navigationFallbackRewrite;
                    if (!shouldDisplayNotFoundPage) {
                        core_1.logger.silly(`rewrite request to ${chalk_1.default.yellow(filePathFromRequest)}`);
                        req.url = filePathFromRequest;
                    }
                }
            }
        }
        core_1.logger.silly(` - shouldDisplayNotFoundPage: ${chalk_1.default.yellow(shouldDisplayNotFoundPage)}`);
        if (shouldDisplayNotFoundPage) {
            (0, error_page_handler_1.handleErrorPage)(req, res, 404, responseOverridesRule);
            return {
                isFunctionFallbackRequest: false,
                isSuccessfulSiteHit: false,
            };
        }
    }
    if (!filePathFromRequest) {
        return {
            isFunctionFallbackRequest: false,
            isSuccessfulSiteHit: false,
        };
    }
    // if the file path is a remote HTTP request, this means we are connecting to a dev server.
    // exist here and let the remote server handle the request.
    if ((0, core_1.isHttpUrl)(filePathFromRequest)) {
        return {
            isFunctionFallbackRequest: false,
            isSuccessfulSiteHit: true,
        };
    }
    // mime type
    const mimeType = (0, routes_engine_1.getMimeTypeForExtension)(filePathFromRequest, mimeTypeRule);
    res.setHeader("Content-Type", mimeType);
    // compute both global and route headers
    const matchingRouteHeaders = (0, routes_engine_1.getHeadersForRoute)(routeHeaders, globalHeaders);
    if (responseOverridesRule) {
        // Handle HEAD request
        if (req.method === "HEAD") {
            (0, routes_engine_1.updateResponseHeaders)(res, matchingRouteHeaders);
            res.statusCode = 200;
            return {
                isFunctionFallbackRequest: false,
                isSuccessfulSiteHit: true,
            };
        }
        // Handle OPTIONS request
        if (req.method === "OPTIONS") {
            (0, routes_engine_1.updateResponseHeaders)(res, matchingRouteHeaders);
            const allowStr = "GET, HEAD, OPTIONS";
            res.setHeader("Allow", allowStr);
            res.statusCode = 204; // No Content
            return {
                isFunctionFallbackRequest: false,
                isSuccessfulSiteHit: true,
            };
        }
    }
    // Handle GET request
    (0, routes_engine_1.updateResponseHeaders)(res, matchingRouteHeaders);
    req.url = filePathFromRequest;
    return {
        isSuccessfulSiteHit: true,
        isFunctionFallbackRequest: false,
    };
}
exports.getStorageContent = getStorageContent;
//# sourceMappingURL=response.middleware.js.map