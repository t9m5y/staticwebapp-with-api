"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isRequestPathExcludedFromNavigationFallback = exports.navigationFallback = void 0;
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const core_1 = require("../../../core");
const glob_1 = require("../../../core/utils/glob");
const constants_1 = require("../../../core/constants");
const route_processor_1 = require("../route-processor");
const routes_1 = require("./routes");
const env_1 = require("../../../core/env");
// See: https://docs.microsoft.com/azure/static-web-apps/configuration#fallback-routes
function navigationFallback(req, res, navigationFallback) {
    var _a, _b;
    let originlUrl = req.url;
    core_1.logger.silly("checking navigation fallback...");
    // don't process .auth requests
    if (originlUrl === null || originlUrl === void 0 ? void 0 : originlUrl.startsWith("/.auth")) {
        core_1.logger.silly(` - request ${chalk_1.default.yellow(originlUrl)} is auth`);
        core_1.logger.silly(` - ignoring navigation fallback`);
        return false;
    }
    // exit if no rewrite rule provided
    if (!(navigationFallback === null || navigationFallback === void 0 ? void 0 : navigationFallback.rewrite)) {
        core_1.logger.silly(` - rewrite rule is invalid (got: ${chalk_1.default.yellow(navigationFallback === null || navigationFallback === void 0 ? void 0 : navigationFallback.rewrite)})`);
        core_1.logger.silly(` - ignoring navigation fallback`);
        return false;
    }
    // exit if no exclude property provided, or exclude list is empty
    if (!(navigationFallback === null || navigationFallback === void 0 ? void 0 : navigationFallback.exclude) || ((_a = navigationFallback === null || navigationFallback === void 0 ? void 0 : navigationFallback.exclude) === null || _a === void 0 ? void 0 : _a.length) === 0) {
        core_1.logger.silly(` - exclude rule is invalid (got: ${chalk_1.default.yellow(navigationFallback === null || navigationFallback === void 0 ? void 0 : navigationFallback.exclude)})`);
        core_1.logger.silly(` - ignoring navigation fallback`);
        return false;
    }
    // make sure we have a leading / in the URL
    if (navigationFallback.rewrite.startsWith("/") === false) {
        navigationFallback.rewrite = `/${navigationFallback.rewrite}`;
    }
    // is the requested file available on disk?
    const filename = (0, routes_1.getIndexHtml)(originlUrl);
    const filepath = path_1.default.join((0, env_1.swaCLIEnv)().SWA_CLI_OUTPUT_LOCATION, filename);
    const isFileFoundOnDisk = fs_1.default.existsSync(filepath);
    core_1.logger.silly(` - url: ${chalk_1.default.yellow(originlUrl)}`);
    core_1.logger.silly(` - file: ${chalk_1.default.yellow(filepath)} (exists: ${chalk_1.default.yellow(isFileFoundOnDisk)})`);
    // parse the exclusion rules and match at least one rule
    const isMatchedExcludeRule = (_b = navigationFallback === null || navigationFallback === void 0 ? void 0 : navigationFallback.exclude) === null || _b === void 0 ? void 0 : _b.some((filter) => {
        if ((0, glob_1.isValidGlobExpression)(filter) === false) {
            core_1.logger.silly(` - invalid rule ${chalk_1.default.yellow(filter)}`);
            core_1.logger.silly(` - mark as no match`);
            return false;
        }
        // we don't support full globs in the config file.
        // add this little utility to convert a wildcard into a valid glob pattern
        const regexp = new RegExp(`^${(0, glob_1.globToRegExp)(filter)}$`);
        const isMatch = regexp.test(originlUrl);
        core_1.logger.silly(`   - rule: ${chalk_1.default.yellow(filter)}`);
        core_1.logger.silly(`   - regexp: ${chalk_1.default.yellow(regexp)}`);
        core_1.logger.silly(`   - isRegexpMatch: ${chalk_1.default.yellow(isMatch)}`);
        return isMatch;
    });
    core_1.logger.silly(` - isMatchedExcludeRule: ${chalk_1.default.yellow(isMatchedExcludeRule)}`);
    // rules logic:
    // 1. if no exclude rules are provided, rewrite by default
    // 2. if a file exists on disk, and match exclusion => return it
    // 3. if a file doesn't exist on disk, and match exclusion => 404
    // 4. if a file exists on disk, and doesn't match exclusion => /index.html
    // 5. if a file doesn't exist on disk, and doesn't match exclusion => /index.html
    // note: given the complexity of all possible combinations, don't refactor the code below
    let rewriteUrl = req.url;
    // 1.
    if (!navigationFallback.exclude || navigationFallback.exclude.length === 0) {
        rewriteUrl = navigationFallback.rewrite;
        core_1.logger.silly(` - no exclude rules are provided (rewrite by default)`);
        core_1.logger.silly(` - url: ${chalk_1.default.yellow(rewriteUrl)}`);
    }
    // 2.
    else if (isFileFoundOnDisk === true && isMatchedExcludeRule === true) {
        rewriteUrl = req.url;
        core_1.logger.silly(` - file exists on disk, and match exclusion`);
        core_1.logger.silly(` - url: ${chalk_1.default.yellow(rewriteUrl)}`);
    }
    // 3.
    else if (isFileFoundOnDisk === false && isMatchedExcludeRule === true) {
        res.statusCode = 404;
        core_1.logger.silly(` - file doesn't exist on disk, and match exclusion`);
        core_1.logger.silly(` - statusCode: ${chalk_1.default.yellow(404)}`);
    }
    // 4.
    else if (isFileFoundOnDisk === true && isMatchedExcludeRule === false) {
        rewriteUrl = navigationFallback.rewrite;
        core_1.logger.silly(` - file exists on disk, and doesn't match exclusion`);
        core_1.logger.silly(` - url: ${chalk_1.default.yellow(rewriteUrl)}`);
    }
    // 5.
    else if (isFileFoundOnDisk === false && isMatchedExcludeRule === false) {
        rewriteUrl = navigationFallback.rewrite;
        core_1.logger.silly(` - file doesn't exist on disk, and doesn't match exclusion`);
        core_1.logger.silly(` - url: ${chalk_1.default.yellow(rewriteUrl)}`);
    }
    req.url = rewriteUrl;
    return true;
}
exports.navigationFallback = navigationFallback;
function isRequestPathExcludedFromNavigationFallback(normalizedDecodedRequestPath, navigationFallback, matchedRoute) {
    core_1.logger.silly(`checking if request is excluded from navigation fallback`);
    core_1.logger.silly(` - request: ${chalk_1.default.yellow(normalizedDecodedRequestPath)}`);
    const excludedPathRules = navigationFallback === null || navigationFallback === void 0 ? void 0 : navigationFallback.exclude;
    if (!normalizedDecodedRequestPath || (excludedPathRules === null || excludedPathRules === void 0 ? void 0 : excludedPathRules.length) === 0) {
        core_1.logger.silly(` - exclude: ${chalk_1.default.yellow(false)}`);
        return false;
    }
    const isMatchedExcludeRule = excludedPathRules === null || excludedPathRules === void 0 ? void 0 : excludedPathRules.some((filter) => {
        // override the route with the current filter rule
        const excludedPath = {
            ...matchedRoute,
            route: filter,
        };
        core_1.logger.silly(` - excludedPath: ${chalk_1.default.yellow(filter)}`);
        return (0, route_processor_1.doesRequestPathMatchRoute)(normalizedDecodedRequestPath, excludedPath, null, null, constants_1.AUTH_STATUS.NoAuth);
    });
    if (isMatchedExcludeRule) {
        core_1.logger.silly(` - don't rewrite ${chalk_1.default.yellow(normalizedDecodedRequestPath)}`);
    }
    else {
        core_1.logger.silly(` - rewrite ${chalk_1.default.yellow(normalizedDecodedRequestPath)} to ${chalk_1.default.yellow(navigationFallback === null || navigationFallback === void 0 ? void 0 : navigationFallback.rewrite)}`);
    }
    return isMatchedExcludeRule;
}
exports.isRequestPathExcludedFromNavigationFallback = isRequestPathExcludedFromNavigationFallback;
//# sourceMappingURL=navigation-fallback.js.map