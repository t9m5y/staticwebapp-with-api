"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getIndexHtml = exports.isRequestMethodValid = exports.tryGetMatchingRoute = exports.applyRedirectResponse = exports.isRouteRequiringUserRolesCheck = exports.tryFindFileForRequest = void 0;
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const config_1 = require("../../../config");
const core_1 = require("../../../core");
const constants_1 = require("../../../core/constants");
const auth_handler_1 = require("../../handlers/auth.handler");
const route_processor_1 = require("../route-processor");
function tryFindFileForRequest(rawRequestPath) {
    core_1.logger.silly(`finding file for request`);
    // percent decode request path
    let requestPath = decodeURIComponent(rawRequestPath);
    if (requestPath.endsWith("/")) {
        requestPath = getIndexHtml(requestPath);
    }
    core_1.logger.silly(` - requestPath: ${chalk_1.default.yellow(requestPath)}`);
    if (config_1.DEFAULT_CONFIG.outputLocation) {
        const filePath = path_1.default.join(config_1.DEFAULT_CONFIG.outputLocation, requestPath);
        core_1.logger.silly(` - filePath: ${chalk_1.default.yellow(filePath)}`);
        const isFileExists = fs_1.default.existsSync(filePath);
        core_1.logger.silly(` - exists: ${chalk_1.default.yellow(isFileExists)}`);
        return isFileExists ? requestPath : null;
    }
    return null;
}
exports.tryFindFileForRequest = tryFindFileForRequest;
function isRouteRequiringUserRolesCheck(req, matchingRoute, isFunctionRequest, authStatus) {
    var _a, _b, _c;
    core_1.logger.silly(`checking authorizations for route`);
    if (!matchingRoute) {
        core_1.logger.silly(` - no matching rule`);
        core_1.logger.silly(` - access authorized`);
        return true;
    }
    if (((_a = matchingRoute.allowedRoles) === null || _a === void 0 ? void 0 : _a.length) === 0) {
        core_1.logger.silly(` - no allowedRoles provided`);
        core_1.logger.silly(` - access authorized`);
        return true;
    }
    const shouldCheckRoles = Boolean(authStatus != constants_1.AUTH_STATUS.HostNameAuthLogin &&
        matchingRoute.allowedRoles &&
        matchingRoute.allowedRoles.length > 0 &&
        !matchingRoute.allowedRoles.includes("anonymous"));
    core_1.logger.silly(` - shouldCheckRoles: ${chalk_1.default.yellow(shouldCheckRoles)}`);
    const shouldLookupAuthCookie = shouldCheckRoles || isFunctionRequest || authStatus == constants_1.AUTH_STATUS.AuthMe || authStatus == constants_1.AUTH_STATUS.HostNameAuthPurge;
    core_1.logger.silly(` - shouldLookupAuthCookie: ${chalk_1.default.yellow(shouldLookupAuthCookie)}`);
    if (shouldLookupAuthCookie) {
        const clientPrincipalInternal = ((_b = req.headers) === null || _b === void 0 ? void 0 : _b.cookie) ? (0, core_1.decodeCookie)((_c = req.headers) === null || _c === void 0 ? void 0 : _c.cookie) : null;
        const doesAuthCookieExist = !!clientPrincipalInternal;
        if (shouldCheckRoles && !doesAuthCookieExist) {
            core_1.logger.silly(` - secure route found but cookies not found`);
            core_1.logger.silly(` - access not authorized`);
            return false;
        }
        const userRoles = clientPrincipalInternal === null || clientPrincipalInternal === void 0 ? void 0 : clientPrincipalInternal.userRoles;
        core_1.logger.silly(` - userRoles: ${chalk_1.default.yellow((userRoles === null || userRoles === void 0 ? void 0 : userRoles.length) ? userRoles : "<empty>")}`);
        core_1.logger.silly(` - allowedRoles: ${chalk_1.default.yellow(matchingRoute.allowedRoles)}`);
        core_1.logger.silly(matchingRoute);
        const matchedRoles = userRoles === null || userRoles === void 0 ? void 0 : userRoles.filter((value) => { var _a; return (_a = matchingRoute.allowedRoles) === null || _a === void 0 ? void 0 : _a.includes(value); });
        core_1.logger.silly(` - matchedRoles: ${chalk_1.default.yellow((matchedRoles === null || matchedRoles === void 0 ? void 0 : matchedRoles.length) ? matchedRoles : "<empty>")}`);
        const isUserAuthenticatedOrAnonymous = (matchedRoles === null || matchedRoles === void 0 ? void 0 : matchedRoles.length) > 0;
        core_1.logger.silly(` - isUserAuthenticatedOrAnonymous: ${chalk_1.default.yellow(isUserAuthenticatedOrAnonymous)}`);
        if (shouldCheckRoles && !isUserAuthenticatedOrAnonymous) {
            core_1.logger.silly(` - secure route found but roles don't match`);
            core_1.logger.silly({ allowedRoles: matchingRoute.allowedRoles });
            core_1.logger.silly(` - access not authorized`);
            return false;
        }
    }
    core_1.logger.silly(` - access authorized`);
    return true;
}
exports.isRouteRequiringUserRolesCheck = isRouteRequiringUserRolesCheck;
function applyRedirectResponse(req, res, matchedRoute) {
    const redirect = matchedRoute === null || matchedRoute === void 0 ? void 0 : matchedRoute.redirect;
    if (redirect && redirect !== req.url) {
        const statusCodeToServe = parseInt(`${matchedRoute === null || matchedRoute === void 0 ? void 0 : matchedRoute.statusCode}`, 10) === 301 ? 301 : 302;
        res.statusCode = statusCodeToServe;
        res.setHeader("Location", redirect);
        core_1.logger.silly(` - will redirect to ${chalk_1.default.yellow(redirect)} (statusCode: ${chalk_1.default.yellow(statusCodeToServe)})`);
    }
}
exports.applyRedirectResponse = applyRedirectResponse;
function tryGetMatchingRoute(req, userConfig) {
    var _a, _b, _c;
    const host = `${constants_1.SWA_CLI_APP_PROTOCOL}://${(_a = req === null || req === void 0 ? void 0 : req.headers) === null || _a === void 0 ? void 0 : _a.host}`;
    const sanitizedUrl = new URL(req.url, host);
    const requestPathFileExtension = path_1.default.extname(sanitizedUrl.toString());
    const isFileRequest = !!requestPathFileExtension;
    const requestMethod = req.method;
    const isLegacyConfigFile = userConfig === null || userConfig === void 0 ? void 0 : userConfig.isLegacyConfigFile;
    if (((_b = userConfig === null || userConfig === void 0 ? void 0 : userConfig.routes) === null || _b === void 0 ? void 0 : _b.length) === 0) {
        return;
    }
    let routeDef = undefined;
    for (let i = 0; i < ((_c = userConfig === null || userConfig === void 0 ? void 0 : userConfig.routes) === null || _c === void 0 ? void 0 : _c.length); i++) {
        routeDef = userConfig === null || userConfig === void 0 ? void 0 : userConfig.routes[i];
        let route = routeDef === null || routeDef === void 0 ? void 0 : routeDef.route;
        if (!route) {
            // this is an invalid route, ignore it
            continue;
        }
        const isMatchingRoute = isLegacyConfigFile
            ? (0, route_processor_1.doesRequestPathMatchLegacyRoute)(sanitizedUrl.pathname, routeDef, (0, auth_handler_1.isAuthRequest)(req), isFileRequest)
            : (0, route_processor_1.doesRequestPathMatchRoute)(sanitizedUrl.pathname, routeDef, requestMethod, routeDef === null || routeDef === void 0 ? void 0 : routeDef.methods, constants_1.AUTH_STATUS.NoAuth /* TODO get the right auth status */);
        if (isMatchingRoute) {
            // if the rule isn't a redirect rule, no need to check for circular redirect
            if (!(routeDef === null || routeDef === void 0 ? void 0 : routeDef.redirect)) {
                return routeDef;
            }
            // this rule will result in an infinite redirect loop so keep searching for another rule
            const redirectUrl = new URL(routeDef.redirect || "/", host);
            if (sanitizedUrl.toString() === redirectUrl.pathname || sanitizedUrl.toString() === redirectUrl.toString()) {
                continue;
            }
            routeDef = {
                ...routeDef,
                redirect: redirectUrl.toString(),
            };
            return routeDef;
        }
    }
    return;
}
exports.tryGetMatchingRoute = tryGetMatchingRoute;
function isRequestMethodValid(req, isFunctionRequest, isAuth) {
    core_1.logger.silly(`checking HTTP method: ${chalk_1.default.yellow(req.method)}`);
    if (isFunctionRequest || isAuth) {
        core_1.logger.silly(` - function or auth request detected, method is valid`);
        return true;
    }
    if (constants_1.ALLOWED_HTTP_METHODS_FOR_STATIC_CONTENT.includes(req.method)) {
        core_1.logger.silly(` - method is valid (allow-list: ${chalk_1.default.yellow(constants_1.ALLOWED_HTTP_METHODS_FOR_STATIC_CONTENT.join(","))})`);
        return true;
    }
    // Deny everything else
    core_1.logger.silly(` - method is invalid. Deny request`);
    return false;
}
exports.isRequestMethodValid = isRequestMethodValid;
function getIndexHtml(requestPath) {
    // skip requests that contains file extensions
    if ((requestPath === null || requestPath === void 0 ? void 0 : requestPath.toLocaleLowerCase().endsWith("index.html")) || (requestPath === null || requestPath === void 0 ? void 0 : requestPath.includes("."))) {
        return requestPath;
    }
    return (requestPath === null || requestPath === void 0 ? void 0 : requestPath.endsWith("/")) ? `${requestPath}index.html` : `${requestPath}/index.html`;
}
exports.getIndexHtml = getIndexHtml;
//# sourceMappingURL=routes.js.map